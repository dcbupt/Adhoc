# Adhoc
> 基于ucos-II内核实现Adhoc网络节点的链路层和网络层协议

## ucos-II
μC/OS-II（Micro Control Operation System Two）是一个可以基于ROM运行的、可裁减的、抢占式、实时多任务内核，具有高度可移植性，特别适合于微处理器和控制器。<BR>
为了提供最好的移植性能，uC/OS II最大程度上使用ANSI C语言进行开发，并且已经移植到近40多种处理器体系上，涵盖了从8位到64位各种CPU（包括DSP）。<BR>
μC/OS-II可以简单的视为一个多任务调度器，在这个任务调度器之上完善并添加了和多任务操作系统相关的系统服务，如信号量、邮箱等。其主要特点有公开源代码，代码结构清晰、明了，注释详尽，组织有条理，可移植性好，可裁剪，可固化。内核属于抢占式，最多可以管理60个任务。<BR>
μC/OS-II可以大致分成核心、任务处理、时间处理、任务同步与通信，CPU的移植等5个部分。<BR>
（1）	核心部分（OSCore.c），是操作系统的处理核心，包括操作系统初始化、操作系统运行、中断进出的前导、时钟节拍、任务调度、事件处理等多部分。能够维持系统基本工作的部分都在这里。<BR>
（2）	任务处理部分（OSTask.c） 　任务处理部分中的内容都是与任务的操作密切相关的。包括任务的建立、删除、挂起、恢复等等。因为μC/OS-II是以任务为基本单位调度的，所以这部分内容也相当重要。<BR>
（3）	时钟部分（OSTime.c），μC/OS-II中的最小时钟单位是timetick（时钟节拍）。任务延时等操作是在这里完成的。<BR>
（4）	任务同步和通信部分，为事件处理部分，包括信号量、邮箱、消息队列、事件标志等部分；主要用于任务间的互相联系和对临界资源的访问。<BR>
（5）	与CPU的接口部分，是指μC/OS-II针对所使用的CPU的移植部分。由于μC/OS-II是一个通用性的操作系统，所以对于关键问题上的实现，还是需要根据具体CPU的具体内容和要求作相应的移植。这部分内容由于牵涉到SP等系统指针，所以通常用汇编语言编写。主要包括中断级任务切换的底层实现、任务级任务切换的底层实现、时钟节拍的产生和处理、中断的相关处理部分等内容 <BR>

## 系统总体介绍
整个自组织网络架构，最上层是应用层，应用层生成的数据调用网络层接口向下发送的链路层，链路层会调用LVDS接口设置物理层状态，进行天线对准，建立通信链路，发送数据包。同时物理层的数据也由LVDS接口传输到链路层，再传输到网络层、应用层。链路层维护当前节点的状态，以及当前节点的所有邻居节点的状态。网络层根据邻居列表计算连通矩阵。

## 系统框架设计
由于协议部分与应用层部分以及信息控制板与通信终端之间交互的部分的是独立运行的进程，为了控制协议部分的运转流程，采用基于事件驱动的方式，进程之间通过MARS OS提供的IPC结构体进行通信。上层应用层以及信息控制板与通信终端之间交互的进程作为事件的生产者，而协议进程Protocol作为事件的消费者。事件通过操作系统提供的IPC结构体在不同的进程间进行传递。

### 主函数介绍
主函数完成启动μC/OS-II操作系统，初始化本节点参数信息和创建两个主进程和一个定时器进程，并通过启动μC/OS-II多任务调度环境实现adhoc链路层和网络层的协议

### 主进程介绍
两个主进程：Protocol进程和Recv_data_from_lvds进程。<br>
Protocol进程和Recv_data_from_lvds进程实现不同的分工，彼此又通过事件消息队列进行通信。<br>
（1）	Protocol进程：负责监听事件消息队列里的消息。当有新的消息进入队列，Protocol进程负责根据事件消息类型调用相应的处理接口实现链路层和网络层功能，即Protocol进程扮演的是事件的消费者，通过事件驱动的方式实现协议。<br>
（2）	Recv_data_from_lvds：负责监听LVDS接口的数据。当有数据到来时，Recv_data_from_lvds接口根据数据类型向事件消息队列发送不同类型的事件消息，即Recv_data_from_lvds进程扮演的是事件的生产者，读取物理层传来的数据交由Protocol进程实现上层协议

### 主定时器介绍
（1）	一个定时器进程：set_timer进程。<br>
（2）	负责延时固定时间后，向Protocol进程发送定时器到时事件，触发Protocol进程调用宽波束消息发送接口广播组网数据帧。

### 事件类型
App2NetEvent
由应用层进程产生的，发送数据包的事件
<BR>
Phy2MacOnWideEvent
由信息控制板与通信终端之间交互的进程产生，表示收到宽波束数据包的事件
<BR>
Phy2MacOnNarrowEvent
由信息控制板与通信终端之间交互的进程产生，表示收到窄波束数据包的事件
<BR>
SetWideBeamEvent
由信息控制板与通信终端之间交互的进程产生，表示收到宽波束设置命令响应的事件
<BR>
SetNarrowBeamEvent
由信息控制板与通信终端之间交互的进程产生，表示收到窄波束设置命令响应的事件
<BR>
SetLinkEvent
由信息控制板与通信终端之间交互的进程产生，表示收到链路参数设置命令响应的事件
<BR>
InitTimerEvent
由定时器产生的，表示到了本节点宽波束时隙，发送组网信息帧的事件
<BR>
TimeUpEvent
由定时器产生的，表示本节点与相应节点超过连通计时的事件.

### 描述事件的结构体
```
typedef struct Protocol_Message{
INT8U    mesType;         
INT32U   len;          
INT8U    desID;        
INT8U    memType;       	
void *   data;         
}Protocol_Message;

```

### 连通性矩阵更新策略
本节点根据自身天线接收到的信息判断周边可通信的节点，更新矩阵中与自身节点相关的矩阵元素，并通过接收别的节点发布的连通性矩阵，更新其它节点间的连通性元素信息。并在自身时隙时，将更新后的连通性矩阵发布出去，供其它节点更新。

### 宽波束消息发送
（1）	对应接口:send_node_msg   (接口位于mac_laye.c) <br>
（2）	在每个节点所属时隙，如果网络层缓存队列没有DATA且天线均处于宽波束状态，节点发送一次宽波束组网数据帧，广播本节点的位置信息、速度信息、时间信息、压缩后的连通矩阵。<br>
（3）	如果网络层有DATA且天线工作在宽波束，发送一次宽波束数传请求帧RTS，并携带建立窄波束通信的目的节点ID。<BR>

### 宽波束消息接收
（1）	对应接口：read_node_msg   (接口位于mac_laye.c) <br>
（2）	解析宽波束消息，更新邻居节点的位置、速度信息，确定相邻节点的位置。 <BR>
（3）	解析压缩后的全联通矩阵，更新本地连通矩阵。<BR>
（4）	启动定时器，如果定时器到时都没有再次收到该邻居节点的宽波束消息，认为这个节点不再是邻居节点。 <BR>
（5）	如果收到的是宽波束数传请求帧，判断目的节点是否为本节点，如果是，进行窄波束数传前的准备。<BR>

### 窄波束消息流程
（1）	当源节点有数据要发送时，在宽波束工作模式下，发送RTS=1的节点信息后，进入窄波束工作模式，等待CTS回复。<BR>
（2）	如果在源节点下一时隙到来时，仍未接收到信息，返回宽波束工作模式。<BR>
（3）	当目的节点收到源节点的RTS后，进入窄波束工作模式，发送CTS，等待数据接收。<BR>
（4）	源节点收到CTS后，开始发送数据。<BR>
（5）	目的节点对接收到的正确数据发送ACK给予证实。<BR>
（6）	源节点收到ACK后，如有数据，继续发送，如果没有，则发送END消息，返回宽波束工作模式结束发送。<BR>
（7）	目的节点收到END消息后，回复END消息，之后返回宽波束工作模式。<BR>
（8）	当接收节点的数据缓存队列BUF满时，回复ACK_OVERFLOW消息，返回宽波束工作模式。<BR>
（9）	发送节点收到ACK_OVERFLOW消息，返回宽波束工作模式。<BR>

## 网络层
### 接收应用层数据
应用层接收数据的接口：void packetProcess( uint8_t destID, void* point2data, uint32_t length);<BR>
参数说明：<BR>
destID: 数据发往的目标地址<BR>
point2data: 指向数据内存的地址<BR>
length: 数据块的长度<BR>
处理流程：<BR>
接口从应用层收到数据，根据目标地址，在路由表中查找下一跳地址，如果查到，则添加相应的网络层报头，然后调用MAC层提供的接口，将数据交接给MAC层进行处理；如果没有相应路由表项，则丢弃数据包，并通知MAC层启动全连通矩阵更新流程。<BR>

### 接收MAC层数据
接口定义：  receiveFromMac( void * point2data, uint32_t length);<BR>
参数说明：<BR>
point2data:  指向数据包内存地址的指针<BR>
length:  数据包的总长度<BR>
处理流程：<BR>
接口从MAC层收到数据后，根据IP报文头部信息中的目标地址判断，如果目标地址是本节点的IP地址，则将数据包上传给应用层；否则，处理转发流程，根据目标地址查找路由表，如果找到路由，则调用MAC层接口处理转发；如果没有找到路由，则丢弃数据包<BR>

